2学习一门编程语言的基本步骤
（1）了解背景知识 历史 现状 特点 应用场景
（2）搭建开发环境 编写一个 helloworid
（3）变量和常量
（4）数据类型
（5）运算符
（6）逻辑结构
（7）通用小程序
（8）函数和对象
（9）第三方库 框架
3JS 概述
（1）历史
1995年JS 最早出现在Netscape公司的游览器中
1997年 出现JS 的标准规范 ECMAScirpt
2009年 JS 遵循 CommonJS 规范 开始向服务器端发展
出现nodejs。
（2）现状
既可以运行在客户端游览器，也可以运行在服务器端
（3）特点
解释型语言 编译一行执行一行
弱类型语言 
基于对象
跨平台
（4）应用场景
用于浏览器端的交互效果
用于服务器端的创建web服务器、操作数据库、操作文件..
4搭建JS开发环境
（1）浏览器自带的JS解释器
（2）nodejs下的JS解释器（服务器端）
    http://nodejs.org
在命令行下 输入node -v
（3）执行JS代码
浏览器：
创建01.js 和01.html
在html文件中引入js脚本
<script src="01.js"></script>
nodejs:
node 路径
5.JS代码规范
（1）区分大小写
（2）每行代码结束的分号可加可不加 建议都加
（3）注释为//...   /**/
console.log()
6.变量
用于存储数据的容器
（1）声明变量
 var a=1;
(2)声明多个变量
var x=1,y=2;
多个变量之间用逗号隔开
（3）变量的命名规则
变量名称由字母、数字、下划线、美元符号组成
数字出现在开头
不能使用关键字和保留字作为变量名
（4）声明变量未赋值
结果为 undefined 未定义
7.常量-const
一旦声明就不允许重新赋值
使用关键字const
const pi=3.14;
8数值类型
分为原始类型和引用类型
原始类型又分为 数值型、字符串型、布尔型、未定义型、空
（1）数值型
分为整型和浮点型
整型占4个字节 浮点型占8个字节
8进制以0开头 列如012对应十进制的10
16进制以0x开头  不区分大小写 列如 0x20对应十进制的32
时间存储的是距离计算机元年的毫秒数 1970年1月1日0:0:0
3.1415e2 =314.15
 
（2）字符串型
数据被引号所包含就是字符串型 不区分单双引号
查看某个字符的Unicode码
console.log('a'.charCodeAt())
（3）布尔型
在程序中表示真或者假的结果
true/false
常用一些是否的结果 列如 是否登录 注册 
var is Login=false
（4）未定义型
声明了变量未赋值 结果是undefined
（5）空
null 常用于引用类型

五种类型  number、string、boolean、undefined、objet
检测数据类型
typeof 数据 
2.数据类型转换
（1）隐式转换
①数值型+字符串型 数值型转成字符串型
JS中加号（+）作用
执行加法运算
字符串的拼接
②数值型+布尔型 布尔型转换成数值型
1+true=2
③字符串型+布尔型 布尔型转换成字符串型
hh+true=hhtrue
 减法、乘法、除法隐式转换
讲运算符两端的数据转成数值型 自动调用Number来转
如果字符串中含有非数字返回NaN（NOT a Numeber）
任何数值和NaN执行减乘除都返回NaN
（2）强制转换
①将数据转为数值型
Number（'9'）//9
Number（'2a'）NaN
Number(true)//1
Number(undefined)//NaN
Number(null)//0
②将数据转为整型
parseInt(2.5)=2
parseInt('2.9a')=2
parseInt('a2')=NaN
③将数据转换为浮点型
parseFloat（'2.9a'）//2.9
parseFloat('a2')//NaN
parsInt和parsFloat在将布尔型 未定义型空转数据的时候都返回NaN
④将数值型和布尔型转成字符串型
toString()
var n=5;
n.toString();//'5'
3运算符
由运算符连接操作的数据 所组成的形式就是表达式
（1）算数运算符
+  -  *  /   %取余 ++自增--自减
%取余 
++自增 在当前的基础之上+1
--自减 在当前的基础之上-1
console.log(num++)先打印值后执行自增
console.log(++num)先自增后执行
（2）比较运算符
>= <= <> ==(等于) !=不等于 ===（严格等于/全等于）
！==（不全等于）
返回布尔型的值
==比较两个值是否相等
数字和字符串比较 字符串转为数值型
两个字符串比较 比较的是首个字符的Unicode码
如果首字符相同就按后一个
NaN和任何值比较 都不等 包括自身 都是false
===不仅比较值 还会比较数据类型
（3）逻辑运算符
并且&& 关联的两个条件true 结果才是true 否则false
或者|| 关联的两个条件只需要一个为true 结果就是true
否则false
非（反向）！
逻辑短路：&&当第一个条件为false的时候就不需要再执行第二个条件了
||当第一个条件为true的时候 就不需要再执行第二个条件
注意：逻辑短路无需关注最终结果是true还是false
重点看第二个表达式是否执行
&& || !
（4）位运算符
在执行运算的时候会将数据转成二进制
按位与（&）
3&5
011
101
001
上下两位都是1  结果 1  否则0
按位或（|）
3|5
011
101
111
上下两位含有1 结果1  否则0
按位异或（^）
上下两位不同结果是1相同结果为0
按位右移（>>）删除二进制的最后一位 逐渐变小
按位左移（<<）在二进制的末尾补0 每移动一位增大一倍
（5）赋值运算符
=  += -= *= /= %=
（6）三目运算符
单目运算符：由一个数据和表达式组成
a++  a--   ！a
双目运算符：1+1 3>2 && || ....
三目运算符：由三个数据和运算符组成
条件表达式？表达式1:表达式2
如果条件表达式为true 执行表达式1
如果条件表达式为false 执行表达式2
4.浏览器端函数
alert()弹出警示框
prompt()弹出提示框 输入的值需要使用变量保存 这个值得数据类型是字符串
 程序=数据+算法
程序分为顺序执行、选择执行、循环执行
5流程控制――选择执行
满30减15
if(条件表达式){语句1;}
语句2
如果IF 后的语句只有一行则可以省略大括号的
在条件表达式中有些值默认转成false：
undefined  null 0 NaN ''  
判断一个值是否为NaN isNaN() 是的话返回true 不是返回false
if-else语句
if(条件表达式){语句1;     }else{语句2;}
(3)if-else 嵌套
if(条件表达式1){语句1;    
}else....if(条件表达式n){
  语句n;}else{  语句n+1;//以上所有的条件表达式都为false}
(4)switch-case语句
是一种特殊的分支语句 可以根据一个表达式的不同值 来选择执行不同的语句
switch(表达式){ case 值1://如果表达式的值为值1 
语句1;
break;//结束 不会往后执行其他的语句
.....
default:
语句n;//如果表达式和所有的值比较都是false 执行}
表达式在和case后值比较的时候使用的是全等于 要求值和类型都相等
对比if-else嵌套和switch-case的区别
相同点:两者都可以用于多项分支语句
不同点:if-else可以判断相等或者不等的情况 使用范围更广泛
switch-case只能用于全等的比较 结构上更为清晰合理 执行效率比较高

使用弹出提示框输入商品的价格和数量并计算总价如果满500打9折
使用变量保存余额 如果足以支付打印paysuccess否则打印pay error
(10)实用的项目
1.循环执行
循环：就是一遍又一遍的执行相同或者相似的代码
循环的两个要素：
循环的条件：控制循环的次数
循环体：重新执行的相同或者相似代码
（1）while循环
while(循环条件){//是一个布尔型的值
   循环体  
   }
（2）break
在循环中可以结束任何形式的循环
2.do-while循环
do{
循环体

}while(循环条件);
3.for 循环
for(表达式1;表达式2;表达式3)
{循环体;}
表达式1放初始值
表达式2放循环条件
表达式3放增量
多个循环条件，最后一个起作用
4break 和continue
break:结束循环 后续不会再执行其他的循环
continue：跳过本次循环继续下一次循环
5循环嵌套
alert()警示框
prompt 提示框 数据类型是字符串
isNaN 判断一个数据的值是否为NaN
任意循环之间可以互相嵌套
1函数
parseInt()/parseFloat()/alert()/prompt()/is NaN
函数分为系统函数和自定义函数
function：功能体，函数（方法）可以接收若干个数据 返回处理的结果
用于封装反复执行的代码――饺子机
（1）创建一个普通函数
function 函数名称(){函数体――封装的代码}
调用：函数名称()
（2）创建带有参数的函数
function 函数名字(参数列表){函数体}
调用：函数名称(参数列表)//实际要传递的数据
参数：创建函数时的参数成为形参 调用时的参数成为实参
同时实参会赋值给形参 多个参数之间用,隔开
参数可以有0个或者多个 如果形参未被赋值 值为undefined.
（3）创建带有返回值的函数
function 函数名称(参数列表){函数体    
                return 值;//返回值 就是函数调用后的结果}
调用 
函数名称(参数列表)
注意事项 ：如果函数中没有return 或者return后没有加任何值
返回undefined。return 后的代码不会再执行。


             对比break 和return的用法
break用于结束 switch语句 ，还可以用于提前结束循环。
return用于函数中的返回值，也可以结束函数后续代码执行

2变量作用域
（1）作用域
变量或者函数的可访问范围，分为两种
函数作用域：在函数中使用var声明的变量，只能在函数内部访问
全局作用域：在全局声明的变量可以再任意的合法位置访问
注意：在函数内不使用var 声明的变量 是全局变量 可以再函数外访问

（2）变量声明提升
JS程序在执行前会将使用var声明的变量提升到所在作用域的最前边
但是赋值还是在原来的位置
console.log(a);
var a=1;
提升使用var声明的变量 只是提升声明不会提升赋值
还是原来的位置赋值
（3）函数作用域
函数的可访问范围 分为全局作用域和函数作用域
全局作用域下创建的函数可以在任意作用域下调用
函数作用域下创建的函数只能在这个函数内部调用
函数提升 
和变量提升一样 JS在执行前，会将使用function关键字创建的
函数提升到所在作用域的最前面。在调用的位置执行函数体中的
代码。
4.递归
 在函数内部调用自身，本身是一个死循环。
用法：要有结束的条件，结合着return。

1.匿名函数
没有名称的函数 function(){  }
（1）创建函数
function(){};函数声明创建
var fn=function(形参){函数体};函数表达式的创建
函数名称和函数名称()的区别
列如 fun/fn  fun()/fn()
函数名称就是一个变量 保存的是函数的结构
函数名称()表示函数的调用 得到的是函数的返回结果
对比函数声明和函数表达式的区别
函数声明创建的函数存在提升 可以在任意的合法位置调用
函数表达式创建的函数只存在变量提升，必须先创建再调用
（2）匿名函数自调用
目的：创建函数作用域，防止污染全局
(function(形参){
//函数体中的变量和函数都不能被外部访问
};)(实参);
（3）回调函数
将匿名函数以实参形式传递，此时的形参就是匿名函数的函数名称
例如function fn(a){
调用fn的时候 匿名函数赋给了a a就是函数名字a() 执行传递的
匿名函数体中的代码
}
fn(function(..){...})
2.全局函数
parseInt()将数据转为整型
parseFloat()将数据转为浮点型
encodeURI()对URI中的汉字进行编码
decodeUIR()对以编码的URI进行解码
isNaN()检测一个值是否为NaN是返回true  不是返回false
isFinite()检测一个值是否为有限值 是返回true 不是返回false
eval()执行字符串中的表达式
3.对象
属于引用类型数据
对象：是一组属性(property)和方法(method)的集合
（1）JS中的对象
内置对象：JS提供的
宿主对象：根据不同的执行环境划分
自定义对象：自己创建的对象
（2）自定义对象
对象字面量
内置构造函数
自定义构造函数
（3）使用对象字面量创建对象
使用大括号{}创建空对象
属性名和属性值之间用冒号隔开
多组属性之间用逗号隔开
属性名中引号可加可不加 如果含有特殊字符必须添加
（4）访问对象中的属性
对象.属性名 对象['属性名']
如果属性不存在 返回undefined
（5）使用内置构造函数创建对象
new Object()创建一个空对象
需要访问对象中属性添加每一个属性
（6）遍历对象中的属性
以此访问对象中的每一个属性
for(var key in 对象){
 key 代表对象中的每一个属性名;
 对象[key]获取每个属性值
}
(7)对象中的方法
var person={
    name:'tom',
    say:function(){
      this.name //this指代当前所在的对象
}
}
person.say();//访问对象中的方法 也就是调用函数

5.15
1.判断是否含有某个属性
对象.属性名===undefined 存在返回false 不存在返回true
对象.hasOwnProperty('属性名');存在是true 不存在是false
'属性名' in 对象；存在是true 不存在是false
2.数组
数组是由多个元素组成的集合，每个元素就是一个数据
3.创建数组
（1）数组字面量
[元素1,元素2,元素3,...]
（2）数组元素的访问
数组[下标]; 下标从0开始
不存在返回undefined
（3）内置构造函数
new Array(元素1,元素2,...)
new Array(3);初始化数组的长度为3，可以添加更多个元素;

4.数组的长度
数组.length 获取数组元素的个数
在数组的末尾添加一个新元素
数组[数组.length]=值;
5.数组的分类
分为索引数组和关联数组  
索引数组以0开始的整数作为下标
关联数组以字符串作为下标，关联数组中的元素只能单独添加
6.遍历数组中的元素
（1）for-in
for(var key in 数组){
     key // 要遍历的每个元素的下标
   数组[key]//每个下标对应的元素
}
（2）循环
for(var a=0;a<数组.length;a++){
a表示每个元素的下标
数组[a]代表下标对应的元素
};
只能遍历索引数组；
7.数组中的方法（api）
api：应用程序编程接口，预定义好的一些方法或者函数
toString：将数组中的元素按照逗号分割转为字符串
join('-'):将字符中的元素按照指定的字符分割转为字符串
concat(arr2,arr3..)拼接多个数组
slice(start.end)截取数组中的元素，start是开始下标
end是结尾下标 不包含end本身 如果end为空 截取到最后
如果是负数 表示倒数
splice(start,count,value1,value2...)删除数组中的元素 start开始
的下标 count删除长度 value删除后添加的元素如果count为空删除到最后
start为负数表示倒数
reverse()翻转数组中的元素
sort() 对数组中的元素进行排序 默认按照Unicode码从小到大进行排序
对数字排序
var arr=[1,12,123,23,11,56];
function i(a,b){
  return b-a
} 
console.log(arr.sort(i))
push()在数组的末尾添加元素，返回数组的长度
pop()删除数组的最后一个元素
unshift()在数组的开头添加元素 返回数组的长度
shift()删除数组的第一个元素



1.对象和数组之间的关系
2.二维数组
数组中的每个元素也是数组
var arr=[[],[],[]];
访问二维数组中的元素
arr[下标][下标];
3.字符串对象
包装对象:目的是为了让原始类型可以像引用类型数据一样具有属性
和方法,本质上还是原始类型
JS包装对象有三种: String Number Boolean
将任意的类型转为字符串String()
new String(true) 转为字符串 返回对象
String(true) 转为字符串 返回字符串
字符串,数值,布尔型
对象有属性和方法
（1）转义字符\
转换字符本身的意义
\n 将字符n转义成换行符
\' 将具有特殊意义的单引号转成普通字符
（2）api
toUpperCase() 将英文字母转为大写
toLowerCase()将英文字母转为小写
length 获取字符串的长度
charAt()获取下标对应的字符,等价于 字符串[下标]
indexOf('字符') 获取字符对应的
IndexOf(val,start) 查找字符出现的下标,val要查找的字符
start开始查找的下标 默认为0 如果找不到 返回-1；
lastIndexOf(var) 查找字符最后一次出现的下标 val要查找的字符
找不到返回-1
slice(start,end) 截取字符串 start开始的下标,end结束的下标
不包含end本身如果end为空 截取到最后 如果为负数表示倒数
substr(start,count) 截取字符串 start开始的下标 count截取的长度
如果count为空 截取到最后start为负数表示倒数
substring(start,end)截取字符串 start开始的下标 end结束的下标
如果end为空截取到最后 如果为负数自动转成0 如果start大于end
位置会自动交换
slice和substring对比
slice下标允许使用负数 substring下标为负数自动转成0
slice中开始的下标小于结束的下标 substring下标不分顺序
split(字符)将字符串按照指定的字符str分割成数组和数字下的join
方法是相对的
4.匹配模式
作用:用于查找、替换字符串
（1）match(value)用于查找匹配的字符串 返回
满足所有条件的字符串 组成数组/wenhua/ig
i-ignore 忽略大小写 g-global 全局查找
（2）search(value)用于查找满足条件的第一个字符串的下标
如果找不到 返回-1 功能和indexOf一致
（3）replace(value1,value2) 查找并替换value1是要查找的字符串
value2是要替换的字符串
5.Math对象
实例化 创建对象
new Object()/new Array()/new String()
Math对象不需要使用new创建 可以直接使用
PI 取圆周率
abs() 取绝对值
floor()向下取整
ceil()向上取整
round()四舍五入取整
max()取一组数字的最大值
min()取一组数字的最小值
pow(x,y)取x得y次幂 x**y
random() 取随机数>=0 <1

1.Date对象 
用于对日期时间进行存储和计算
存储距离计算机元年的时间 1970-1-1000
（1）创建Date对象
new Date('2019/5/17 9:52:30')
new Date(2019,4,17,9,52,30);//第二个参数月份
范围0-11
new Date() 存储当前所在系统的日期时间
new Date(1000*60*60*24)存储距离计算机元年的毫秒
计算机元年时间1970-1-1 0:0:0
（2）获取Date对象中的日期时间
getFullYear() 获取年份
getMonth()获取月份 范围0-11
getDate()获取日
getHours()获取小时
getDay()获取星期
getTime()距离计算机元年毫秒
getMilliseconds()毫秒
getMinutes()分
getSeconds()秒;
（3）获取本地字符串格式
toLocaleString()2019-5-17 14:18:30
toLocaleDateString()2019-5-17
toLocaleTimeString()14:18:30
（4）设置日期时间
setFullYear/setMonth/setDate/setHours
setMinutes/setSeconds/setMilliseconds/setTime
setTime以后 所有的日期时间可能会发生变化
（5）赋值一个Date对象
var d1=new Date();
var d2=new Date(d1);复制d1对象d2是一个新对象
2.Number对象
new Number(true) 将数据转为数值 返回对象
Number(true) 将数据转为数值 返回数值
Number.MAX_VALUE  最大值
Number.MIN_VALUE 最小值
toFixed(n)取小数点后n位
toString(n)将数值转为字符串 同时可以设置进制
3.Boolean对象
new Boolean() 将数据转为布尔型 返回对象
Boolean()将数据转为布尔型 返回布尔型
!!数据 将数据隐式转为布尔型
4.错误处理
SyntaxtError 语法错误 错误的使用了中文 缺少括号等
出现之后 所有的代码都不执行
ReferenceError 引用错误，使用了未声明的变量 影响
后续代码的执行
TypeError 类型错误,错误的使用了数据类型 影响后续
代码的执行
RangeEroor 范围错误 参数的使用超出了范围 影响后续
代码的执行
try{
  尝试执行的代码 可能出现错误
}catch(err){
 err捕获到的错误
具体处理错误的内容 
}
5.ES6
	ECMAScript6
http://es6.ruanyifeng.com/ es6 电子书
（1）块级作用域
使用let关键字 声明的变量,只能在块级作用域下
使用 不能被外部访问 不存在变量的提升
块级作用域： if  if-else while do-while
 for switch
（2）箭头函数
是回调函数的另一种写法 和匿名函数不完全一样
sort((a,b)=>{
  return a-b;
})
如果箭头函数的函数体中只有一行代码 并且是return
形式 可以简化为sort((a,b)=>a-b)
1.函数中的参数
ES6允许为形参设置默认值 如果内有传递实参 则自动
调用形参的默认值
function add(a,b,c=0){
  console.log(a+n+c);
}
add(2,5)   
7
2.模板字符串
`在模板字符串中可以用任何形式的字符串 ${js表达式}`

